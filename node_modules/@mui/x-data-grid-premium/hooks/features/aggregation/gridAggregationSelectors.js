"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gridCellAggregationResultSelector = exports.gridAggregationStateSelector = exports.gridAggregationModelSelector = exports.gridAggregationLookupSelector = void 0;
var _internals = require("@mui/x-data-grid-pro/internals");
var _xDataGrid = require("@mui/x-data-grid");
const gridAggregationStateSelector = exports.gridAggregationStateSelector = (0, _internals.createRootSelector)(state => state.aggregation);

/**
 * Get the aggregation model, containing the aggregation function of each column.
 * If a column is not in the model, it is not aggregated.
 * @category Aggregation
 */
const gridAggregationModelSelector = exports.gridAggregationModelSelector = (0, _internals.createSelector)(gridAggregationStateSelector, aggregationState => aggregationState.model);

/**
 * Get the aggregation results as a lookup.
 * @category Aggregation
 */
const gridAggregationLookupSelector = exports.gridAggregationLookupSelector = (0, _internals.createSelector)(gridAggregationStateSelector, aggregationState => aggregationState.lookup);
const gridCellAggregationResultSelector = exports.gridCellAggregationResultSelector = (0, _internals.createSelector)(_xDataGrid.gridRowTreeSelector, gridAggregationLookupSelector, (rowTree, aggregationLookup, {
  id,
  field
}) => {
  let cellAggregationPosition = null;
  const rowNode = rowTree[id];
  if (!rowNode) {
    return null;
  }
  if (rowNode.type === 'group') {
    cellAggregationPosition = 'inline';
  } else if (id.toString().startsWith('auto-generated-group-footer-')) {
    cellAggregationPosition = 'footer';
  }
  if (cellAggregationPosition == null) {
    return null;
  }

  // TODO: Add custom root id
  const groupId = cellAggregationPosition === 'inline' ? id : rowNode.parent ?? '';
  const aggregationResult = aggregationLookup?.[groupId]?.[field];
  if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {
    return null;
  }
  return aggregationResult;
});