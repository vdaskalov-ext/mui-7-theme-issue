"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAggregationLookup = void 0;
var _xDataGridPro = require("@mui/x-data-grid-pro");
var _gridAggregationUtils = require("./gridAggregationUtils");
var _gridAggregationSelectors = require("./gridAggregationSelectors");
const getGroupAggregatedValue = (groupId, apiRef, aggregationRowsScope, aggregatedFields, aggregationRules, position) => {
  const groupAggregationLookup = {};
  const aggregatedValues = [];
  const rowIds = apiRef.current.getRowGroupChildren({
    groupId
  });
  const filteredRowsLookup = (0, _xDataGridPro.gridFilteredRowsLookupSelector)(apiRef);
  rowIds.forEach(rowId => {
    if (aggregationRowsScope === 'filtered' && filteredRowsLookup[rowId] === false) {
      return;
    }

    // If the row is a group, we want to aggregate based on its children
    // For instance in the following tree, we want the aggregated values of A to be based on A.A, A.B.A and A.B.B but not A.B
    // A
    //   A.A
    //   A.B
    //     A.B.A
    //     A.B.B
    const rowNode = (0, _xDataGridPro.gridRowNodeSelector)(apiRef, rowId);
    if (rowNode.type === 'group') {
      return;
    }
    const row = apiRef.current.getRow(rowId);
    for (let j = 0; j < aggregatedFields.length; j += 1) {
      const aggregatedField = aggregatedFields[j];
      const columnAggregationRules = aggregationRules[aggregatedField];
      const aggregationFunction = columnAggregationRules.aggregationFunction;
      const field = aggregatedField;
      if (aggregatedValues[j] === undefined) {
        aggregatedValues[j] = {
          aggregatedField,
          values: []
        };
      }
      if (typeof aggregationFunction.getCellValue === 'function') {
        aggregatedValues[j].values.push(aggregationFunction.getCellValue({
          row
        }));
      } else {
        const colDef = apiRef.current.getColumn(field);
        aggregatedValues[j].values.push(apiRef.current.getRowValue(row, colDef));
      }
    }
  });
  for (let i = 0; i < aggregatedValues.length; i += 1) {
    const {
      aggregatedField,
      values
    } = aggregatedValues[i];
    const aggregationFunction = aggregationRules[aggregatedField].aggregationFunction;
    const value = aggregationFunction.apply({
      values,
      groupId,
      field: aggregatedField // Added per user request in https://github.com/mui/mui-x/issues/6995#issuecomment-1327423455
    });
    groupAggregationLookup[aggregatedField] = {
      position,
      value
    };
  }
  return groupAggregationLookup;
};
const getGroupAggregatedValueDataSource = (groupId, apiRef, aggregatedFields, position) => {
  const groupAggregationLookup = {};
  for (let j = 0; j < aggregatedFields.length; j += 1) {
    const aggregatedField = aggregatedFields[j];
    groupAggregationLookup[aggregatedField] = {
      position,
      value: apiRef.current.resolveGroupAggregation?.(groupId, aggregatedField) ?? ''
    };
  }
  return groupAggregationLookup;
};
const createAggregationLookup = ({
  apiRef,
  aggregationFunctions,
  aggregationRowsScope,
  getAggregationPosition,
  isDataSource
}) => {
  const aggregationRules = (0, _gridAggregationUtils.getAggregationRules)((0, _xDataGridPro.gridColumnLookupSelector)(apiRef), (0, _gridAggregationSelectors.gridAggregationModelSelector)(apiRef), aggregationFunctions, isDataSource);
  const aggregatedFields = Object.keys(aggregationRules);
  if (aggregatedFields.length === 0) {
    return {};
  }
  const aggregationLookup = {};
  const rowTree = (0, _xDataGridPro.gridRowTreeSelector)(apiRef);
  const createGroupAggregationLookup = groupNode => {
    for (let i = 0; i < groupNode.children.length; i += 1) {
      const childId = groupNode.children[i];
      const childNode = rowTree[childId];
      if (childNode.type === 'group') {
        createGroupAggregationLookup(childNode);
      }
    }
    const position = getAggregationPosition(groupNode);
    if (position !== null) {
      if (isDataSource) {
        aggregationLookup[groupNode.id] = getGroupAggregatedValueDataSource(groupNode.id, apiRef, aggregatedFields, position);
      } else if (groupNode.children.length) {
        aggregationLookup[groupNode.id] = getGroupAggregatedValue(groupNode.id, apiRef, aggregationRowsScope, aggregatedFields, aggregationRules, position);
      }
    }
  };
  createGroupAggregationLookup(rowTree[_xDataGridPro.GRID_ROOT_GROUP_ID]);
  return aggregationLookup;
};
exports.createAggregationLookup = createAggregationLookup;