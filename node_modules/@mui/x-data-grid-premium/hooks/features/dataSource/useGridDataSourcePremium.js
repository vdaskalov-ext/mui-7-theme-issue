"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGridDataSourcePremium = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _xDataGridPro = require("@mui/x-data-grid-pro");
var _internals = require("@mui/x-data-grid-pro/internals");
function getKeyPremium(params) {
  return JSON.stringify([params.filterModel, params.sortModel, params.groupKeys, params.groupFields, params.start, params.end, params.aggregationModel]);
}
const options = {
  cacheOptions: {
    getKey: getKeyPremium
  }
};
const useGridDataSourcePremium = (apiRef, props) => {
  const {
    api,
    debouncedFetchRows,
    strategyProcessor,
    events,
    setStrategyAvailability
  } = (0, _internals.useGridDataSourceBasePro)(apiRef, props, options);
  const aggregateRowRef = React.useRef({});
  const processDataSourceRows = React.useCallback(({
    params,
    response
  }, applyRowHydration) => {
    if (response.aggregateRow) {
      aggregateRowRef.current = response.aggregateRow;
    }
    if (Object.keys(params.aggregationModel || {}).length > 0) {
      if (applyRowHydration) {
        apiRef.current.requestPipeProcessorsApplication('hydrateRows');
      }
      apiRef.current.applyAggregation();
    }
    return {
      params,
      response
    };
  }, [apiRef]);
  const resolveGroupAggregation = React.useCallback((groupId, field) => {
    if (groupId === _xDataGridPro.GRID_ROOT_GROUP_ID) {
      return props.dataSource?.getAggregatedValue?.(aggregateRowRef.current, field);
    }
    const row = apiRef.current.getRow(groupId);
    return props.dataSource?.getAggregatedValue?.(row, field);
  }, [apiRef, props.dataSource]);
  const privateApi = (0, _extends2.default)({}, api.private, {
    resolveGroupAggregation
  });
  (0, _xDataGridPro.useGridApiMethod)(apiRef, api.public, 'public');
  (0, _xDataGridPro.useGridApiMethod)(apiRef, privateApi, 'private');
  (0, _internals.useGridRegisterStrategyProcessor)(apiRef, strategyProcessor.strategyName, strategyProcessor.group, strategyProcessor.processor);
  (0, _internals.useGridRegisterPipeProcessor)(apiRef, 'processDataSourceRows', processDataSourceRows);
  Object.entries(events).forEach(([event, handler]) => {
    (0, _xDataGridPro.useGridEvent)(apiRef, event, handler);
  });
  (0, _xDataGridPro.useGridEvent)(apiRef, 'rowGroupingModelChange', () => debouncedFetchRows());
  (0, _xDataGridPro.useGridEvent)(apiRef, 'aggregationModelChange', () => debouncedFetchRows());
  React.useEffect(() => {
    setStrategyAvailability();
  }, [setStrategyAvailability]);
};
exports.useGridDataSourcePremium = useGridDataSourcePremium;