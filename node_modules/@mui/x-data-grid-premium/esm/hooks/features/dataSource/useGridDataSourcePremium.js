import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import { useGridEvent as addEventHandler, useGridApiMethod, GRID_ROOT_GROUP_ID, useGridEvent } from '@mui/x-data-grid-pro';
import { useGridDataSourceBasePro, useGridRegisterStrategyProcessor, useGridRegisterPipeProcessor } from '@mui/x-data-grid-pro/internals';
function getKeyPremium(params) {
  return JSON.stringify([params.filterModel, params.sortModel, params.groupKeys, params.groupFields, params.start, params.end, params.aggregationModel]);
}
const options = {
  cacheOptions: {
    getKey: getKeyPremium
  }
};
export const useGridDataSourcePremium = (apiRef, props) => {
  const {
    api,
    debouncedFetchRows,
    strategyProcessor,
    events,
    setStrategyAvailability
  } = useGridDataSourceBasePro(apiRef, props, options);
  const aggregateRowRef = React.useRef({});
  const processDataSourceRows = React.useCallback(({
    params,
    response
  }, applyRowHydration) => {
    if (response.aggregateRow) {
      aggregateRowRef.current = response.aggregateRow;
    }
    if (Object.keys(params.aggregationModel || {}).length > 0) {
      if (applyRowHydration) {
        apiRef.current.requestPipeProcessorsApplication('hydrateRows');
      }
      apiRef.current.applyAggregation();
    }
    return {
      params,
      response
    };
  }, [apiRef]);
  const resolveGroupAggregation = React.useCallback((groupId, field) => {
    if (groupId === GRID_ROOT_GROUP_ID) {
      return props.dataSource?.getAggregatedValue?.(aggregateRowRef.current, field);
    }
    const row = apiRef.current.getRow(groupId);
    return props.dataSource?.getAggregatedValue?.(row, field);
  }, [apiRef, props.dataSource]);
  const privateApi = _extends({}, api.private, {
    resolveGroupAggregation
  });
  useGridApiMethod(apiRef, api.public, 'public');
  useGridApiMethod(apiRef, privateApi, 'private');
  useGridRegisterStrategyProcessor(apiRef, strategyProcessor.strategyName, strategyProcessor.group, strategyProcessor.processor);
  useGridRegisterPipeProcessor(apiRef, 'processDataSourceRows', processDataSourceRows);
  Object.entries(events).forEach(([event, handler]) => {
    addEventHandler(apiRef, event, handler);
  });
  useGridEvent(apiRef, 'rowGroupingModelChange', () => debouncedFetchRows());
  useGridEvent(apiRef, 'aggregationModelChange', () => debouncedFetchRows());
  React.useEffect(() => {
    setStrategyAvailability();
  }, [setStrategyAvailability]);
};