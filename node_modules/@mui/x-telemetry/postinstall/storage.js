"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TelemetryStorage = void 0;
var _interopRequireWildcard2 = _interopRequireDefault(require("@babel/runtime/helpers/interopRequireWildcard"));
var _crypto = require("crypto");
var _path = _interopRequireDefault(require("path"));
var _notify = _interopRequireDefault(require("./notify"));
var _getEnvironmentInfo = _interopRequireDefault(require("./get-environment-info"));
// This is the key that specifies when the user was informed about telemetry collection.
const TELEMETRY_KEY_NOTIFY_DATE = 'telemetry.notifiedAt';

// This is a quasi-persistent identifier used to dedupe recurring events. It's
// generated from random data and completely anonymous.
const TELEMETRY_KEY_ID = `telemetry.anonymousId`;
function getStorageDirectory(distDir) {
  const env = (0, _getEnvironmentInfo.default)();
  const isLikelyEphemeral = env.isCI || env.isDocker;
  if (isLikelyEphemeral) {
    return _path.default.join(distDir, 'cache');
  }
  return undefined;
}
class TelemetryStorage {
  static async init({
    distDir
  }) {
    const storageDirectory = getStorageDirectory(distDir);
    let conf = null;
    try {
      // `conf` incorrectly throws a permission error during initialization
      // instead of waiting for first use. We need to handle it, otherwise the
      // process may crash.
      const {
        default: Conf
      } = await Promise.resolve().then(() => (0, _interopRequireWildcard2.default)(require('conf')));
      conf = new Conf({
        projectName: 'mui-x',
        cwd: storageDirectory
      });
    } catch (_) {
      conf = null;
    }
    return new TelemetryStorage(conf);
  }
  constructor(conf) {
    this.conf = conf;
    this.notify = () => {
      if (!this.conf) {
        return;
      }

      // The end-user has already been notified about our telemetry integration. We
      // don't need to constantly annoy them about it.
      // We will re-inform users about the telemetry if significant changes are
      // ever made.
      if (this.conf.get(TELEMETRY_KEY_NOTIFY_DATE, '')) {
        return;
      }
      this.conf.set(TELEMETRY_KEY_NOTIFY_DATE, Date.now().toString());
      (0, _notify.default)();
    };
    this.notify();
  }
  get configPath() {
    return this.conf?.path;
  }
  get anonymousId() {
    const val = this.conf && this.conf.get(TELEMETRY_KEY_ID);
    if (val) {
      return val;
    }
    const generated = (0, _crypto.randomBytes)(32).toString('hex');
    this.conf?.set(TELEMETRY_KEY_ID, generated);
    return generated;
  }
}
exports.TelemetryStorage = TelemetryStorage;