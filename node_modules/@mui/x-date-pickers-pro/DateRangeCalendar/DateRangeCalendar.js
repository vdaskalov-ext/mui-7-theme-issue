"use strict";
'use client';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DateRangeCalendar = void 0;
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _clsx = _interopRequireDefault(require("clsx"));
var _useEventCallback = _interopRequireDefault(require("@mui/utils/useEventCallback"));
var _useMediaQuery = _interopRequireDefault(require("@mui/material/useMediaQuery"));
var _resolveComponentProps = _interopRequireDefault(require("@mui/utils/resolveComponentProps"));
var _useSlotProps = _interopRequireDefault(require("@mui/utils/useSlotProps"));
var _styles = require("@mui/material/styles");
var _composeClasses = _interopRequireDefault(require("@mui/utils/composeClasses"));
var _useId = _interopRequireDefault(require("@mui/utils/useId"));
var _xLicense = require("@mui/x-license");
var _internals = require("@mui/x-date-pickers/internals");
var _warning = require("@mui/x-internals/warning");
var _hooks = require("@mui/x-date-pickers/hooks");
var _dateRangeCalendarClasses = require("./dateRangeCalendarClasses");
var _dateUtils = require("../internals/utils/date-utils");
var _dateRangeManager = require("../internals/utils/date-range-manager");
var _DateRangePickerDay = require("../DateRangePickerDay");
var _valueManagers = require("../internals/utils/valueManagers");
var _useDragRange2 = require("./useDragRange");
var _useRangePosition = require("../internals/hooks/useRangePosition");
var _dimensions = require("../internals/constants/dimensions");
var _PickersRangeCalendarHeader = require("../PickersRangeCalendarHeader");
var _useNullablePickerRangePositionContext = require("../internals/hooks/useNullablePickerRangePositionContext");
var _DateRangePickerDay2 = require("../DateRangePickerDay2");
var _jsxRuntime = require("react/jsx-runtime");
const _excluded = ["value", "defaultValue", "referenceDate", "onChange", "className", "classes", "disableFuture", "disablePast", "minDate", "maxDate", "shouldDisableDate", "reduceAnimations", "onMonthChange", "rangePosition", "defaultRangePosition", "onRangePositionChange", "calendars", "currentMonthCalendarPosition", "slots", "slotProps", "loading", "renderLoading", "disableHighlightToday", "focusedView", "onFocusedViewChange", "readOnly", "disabled", "showDaysOutsideCurrentMonth", "dayOfWeekFormatter", "disableAutoMonthSwitching", "autoFocus", "fixedWeekNumber", "disableDragEditing", "displayWeekNumber", "timezone", "availableRangePositions", "views", "view", "openTo", "onViewChange"],
  _excluded2 = ["isDragging", "rangeDragDay", "draggingDatePosition"];
const releaseInfo = "MTc1MDk3NTIwMDAwMA==";
const DateRangeCalendarRoot = (0, _styles.styled)('div', {
  name: 'MuiDateRangeCalendar',
  slot: 'Root'
})({
  display: 'flex',
  flexDirection: 'row'
});
const DateRangeCalendarMonthContainer = (0, _styles.styled)('div', {
  name: 'MuiDateRangeCalendar',
  slot: 'Container',
  overridesResolver: (_, styles) => styles.monthContainer // FIXME: Inconsistent naming with slot
})(({
  theme
}) => ({
  '&:not(:last-of-type)': {
    borderRight: `1px solid ${(theme.vars || theme).palette.divider}`
  }
}));
const weeksContainerHeight = (_dimensions.DAY_RANGE_SIZE + _dimensions.DAY_MARGIN * 2) * 6;
const InnerDayCalendarForRange = (0, _styles.styled)(_internals.DayCalendar)(({
  theme
}) => ({
  minWidth: 312,
  minHeight: weeksContainerHeight,
  [`&.${_dateRangeCalendarClasses.dateRangeCalendarClasses.dayDragging}`]: {
    [`& .${_DateRangePickerDay2.dateRangePickerDay2Classes.root}, & .${_DateRangePickerDay.dateRangePickerDayClasses.day}`]: {
      cursor: 'grabbing'
    },
    [`& .${_DateRangePickerDay.dateRangePickerDayClasses.root}:not(.${_DateRangePickerDay.dateRangePickerDayClasses.rangeIntervalDayHighlightStart}):not(.${_DateRangePickerDay.dateRangePickerDayClasses.rangeIntervalDayHighlightEnd}) .${_DateRangePickerDay.dateRangePickerDayClasses.day}:not(.${_DateRangePickerDay.dateRangePickerDayClasses.notSelectedDate})`]: {
      // we can't override `PickersDay` background color here, because it's styles take precedence
      opacity: 0.6
    }
  },
  [`&:not(.${_dateRangeCalendarClasses.dateRangeCalendarClasses.dayDragging}) .${_DateRangePickerDay.dateRangePickerDayClasses.dayOutsideRangeInterval}`]: {
    '@media (pointer: fine)': {
      '&:hover': {
        border: `1px solid ${(theme.vars || theme).palette.grey[500]}`
      }
    }
  }
}));
const DayCalendarForRange = InnerDayCalendarForRange;
function useDateRangeCalendarDefaultizedProps(props, name) {
  const themeProps = (0, _styles.useThemeProps)({
    props,
    name
  });
  const reduceAnimations = (0, _internals.useReduceAnimations)(themeProps.reduceAnimations);
  const validationProps = (0, _internals.useApplyDefaultValuesToDateValidationProps)(themeProps);
  return (0, _extends2.default)({}, themeProps, validationProps, {
    renderLoading: themeProps.renderLoading ?? (() => /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
      children: "..."
    })),
    reduceAnimations,
    loading: props.loading ?? false,
    openTo: themeProps.openTo ?? 'day',
    views: themeProps.views ?? ['day'],
    calendars: themeProps.calendars ?? 2,
    disableDragEditing: themeProps.disableDragEditing ?? false,
    availableRangePositions: themeProps.availableRangePositions ?? ['start', 'end']
  });
}
const useUtilityClasses = (classes, ownerState) => {
  const slots = {
    root: ['root'],
    monthContainer: ['monthContainer'],
    dayCalendar: [ownerState.isDraggingDay && 'dayDragging']
  };
  return (0, _composeClasses.default)(slots, _dateRangeCalendarClasses.getDateRangeCalendarUtilityClass, classes);
};
/**
 * Demos:
 *
 * - [DateRangePicker](https://mui.com/x/react-date-pickers/date-range-picker/)
 * - [DateRangeCalendar](https://mui.com/x/react-date-pickers/date-range-calendar/)
 *
 * API:
 *
 * - [DateRangeCalendar API](https://mui.com/x/api/date-pickers/date-range-calendar/)
 */
const DateRangeCalendar = exports.DateRangeCalendar = /*#__PURE__*/React.forwardRef(function DateRangeCalendar(inProps, ref) {
  const props = useDateRangeCalendarDefaultizedProps(inProps, 'MuiDateRangeCalendar');
  const shouldHavePreview = (0, _useMediaQuery.default)(_internals.DEFAULT_DESKTOP_MODE_MEDIA_QUERY, {
    defaultMatches: false
  });
  const {
      value: valueProp,
      defaultValue,
      referenceDate,
      onChange,
      className,
      classes: classesProp,
      disableFuture,
      disablePast,
      minDate,
      maxDate,
      shouldDisableDate,
      reduceAnimations,
      onMonthChange,
      rangePosition: rangePositionProp,
      defaultRangePosition: defaultRangePositionProp,
      onRangePositionChange: onRangePositionChangeProp,
      calendars,
      currentMonthCalendarPosition = 1,
      slots,
      slotProps,
      loading,
      renderLoading,
      disableHighlightToday,
      focusedView: focusedViewProp,
      onFocusedViewChange,
      readOnly,
      disabled,
      showDaysOutsideCurrentMonth,
      dayOfWeekFormatter,
      disableAutoMonthSwitching,
      autoFocus,
      fixedWeekNumber,
      disableDragEditing,
      displayWeekNumber,
      timezone: timezoneProp,
      availableRangePositions,
      views,
      view: inView,
      openTo,
      onViewChange
    } = props,
    other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  const rangePositionContext = (0, _useNullablePickerRangePositionContext.useNullablePickerRangePositionContext)();
  const {
    value,
    handleValueChange,
    timezone
  } = (0, _internals.useControlledValue)({
    name: 'DateRangeCalendar',
    timezone: timezoneProp,
    value: valueProp,
    referenceDate,
    defaultValue,
    onChange,
    valueManager: _valueManagers.rangeValueManager
  });
  const {
    view,
    setFocusedView,
    focusedView,
    setValueAndGoToNextView
  } = (0, _internals.useViews)({
    view: inView,
    views,
    openTo,
    onChange: handleValueChange,
    onViewChange,
    autoFocus,
    focusedView: focusedViewProp,
    onFocusedViewChange
  });
  const adapter = (0, _hooks.usePickerAdapter)();
  const id = (0, _useId.default)();
  const {
    rangePosition,
    setRangePosition
  } = (0, _useRangePosition.useRangePosition)({
    rangePosition: rangePositionProp ?? rangePositionContext?.rangePosition,
    defaultRangePosition: defaultRangePositionProp,
    onRangePositionChange: onRangePositionChangeProp ?? rangePositionContext?.setRangePosition
  });
  const handleDatePositionChange = (0, _useEventCallback.default)(position => {
    if (rangePosition !== position) {
      setRangePosition(position);
    }
  });
  const handleSelectedDayChange = (0, _useEventCallback.default)((newDate, selectionState, allowRangeFlip = false) => {
    const {
      nextSelection,
      newRange
    } = (0, _dateRangeManager.calculateRangeChange)({
      newDate,
      adapter,
      range: value,
      rangePosition,
      allowRangeFlip,
      shouldMergeDateAndTime: true,
      referenceDate
    });
    const isNextSectionAvailable = availableRangePositions.includes(nextSelection);
    if (isNextSectionAvailable) {
      setRangePosition(nextSelection);
    }
    const isFullRangeSelected = rangePosition === 'end' && (0, _dateUtils.isRangeValid)(adapter, newRange);
    setValueAndGoToNextView(newRange, isFullRangeSelected || !isNextSectionAvailable ? 'finish' : 'partial', view);
  });
  const handleDrop = (0, _useEventCallback.default)(newDate => {
    handleSelectedDayChange(newDate, undefined, true);
  });
  const shouldDisableDragEditing = disableDragEditing || disabled || readOnly;

  // Range going for the start of the start day to the end of the end day.
  // This makes sure that `isWithinRange` works with any time in the start and end day.
  const valueDayRange = React.useMemo(() => [!adapter.isValid(value[0]) ? value[0] : adapter.startOfDay(value[0]), !adapter.isValid(value[1]) ? value[1] : adapter.endOfDay(value[1])], [value, adapter]);
  const _useDragRange = (0, _useDragRange2.useDragRange)({
      disableDragEditing: shouldDisableDragEditing,
      onDrop: handleDrop,
      onDatePositionChange: handleDatePositionChange,
      adapter,
      dateRange: valueDayRange,
      timezone
    }),
    {
      isDragging,
      rangeDragDay,
      draggingDatePosition
    } = _useDragRange,
    dragEventHandlers = (0, _objectWithoutPropertiesLoose2.default)(_useDragRange, _excluded2);
  const {
    ownerState: pickersOwnerState
  } = (0, _internals.usePickerPrivateContext)();
  const ownerState = (0, _extends2.default)({}, pickersOwnerState, {
    isDraggingDay: isDragging
  });
  const classes = useUtilityClasses(classesProp, ownerState);
  const draggingRange = React.useMemo(() => {
    if (!valueDayRange[0] || !valueDayRange[1] || !rangeDragDay) {
      return [null, null];
    }
    const newRange = (0, _dateRangeManager.calculateRangeChange)({
      adapter,
      range: valueDayRange,
      newDate: rangeDragDay,
      rangePosition,
      allowRangeFlip: true
    }).newRange;
    return newRange[0] !== null && newRange[1] !== null ? [adapter.startOfDay(newRange[0]), adapter.endOfDay(newRange[1])] : newRange;
  }, [rangePosition, rangeDragDay, adapter, valueDayRange]);
  const wrappedShouldDisableDate = React.useMemo(() => {
    if (!shouldDisableDate) {
      return undefined;
    }
    return dayToTest => shouldDisableDate(dayToTest, draggingDatePosition || rangePosition);
  }, [shouldDisableDate, rangePosition, draggingDatePosition]);
  const {
    calendarState,
    setVisibleDate,
    onMonthSwitchingAnimationEnd
  } = (0, _internals.useCalendarState)({
    value: value[0] || value[1],
    referenceDate,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onMonthChange,
    reduceAnimations,
    shouldDisableDate: wrappedShouldDisableDate,
    timezone,
    getCurrentMonthFromVisibleDate: (visibleDate, prevMonth) => {
      const firstVisibleMonth = adapter.addMonths(prevMonth, 1 - currentMonthCalendarPosition);
      const lastVisibleMonth = adapter.endOfMonth(adapter.addMonths(firstVisibleMonth, calendars - 1));

      // The new focused day is inside the visible calendars,
      // Do not change the current month
      if (adapter.isWithinRange(visibleDate, [firstVisibleMonth, lastVisibleMonth])) {
        return prevMonth;
      }

      // The new focused day is after the last visible month,
      // Move the current month so that the new focused day is inside the first visible month
      if (adapter.isAfter(visibleDate, lastVisibleMonth)) {
        return adapter.startOfMonth(adapter.addMonths(visibleDate, currentMonthCalendarPosition - 1));
      }

      // The new focused day is before the first visible month,
      // Move the current month so that the new focused day is inside the last visible month
      return adapter.startOfMonth(adapter.addMonths(visibleDate, currentMonthCalendarPosition - calendars));
    }
  });
  const CalendarHeader = slots?.calendarHeader ?? _PickersRangeCalendarHeader.PickersRangeCalendarHeader;
  const calendarHeaderProps = (0, _useSlotProps.default)({
    elementType: CalendarHeader,
    externalSlotProps: slotProps?.calendarHeader,
    additionalProps: {
      calendars,
      views: ['day'],
      view: 'day',
      currentMonth: calendarState.currentMonth,
      onMonthChange: month => setVisibleDate({
        target: month,
        reason: 'header-navigation'
      }),
      minDate,
      maxDate,
      disabled,
      disablePast,
      disableFuture,
      reduceAnimations,
      timezone,
      slots,
      slotProps
    },
    ownerState
  });

  // TODO: Move this logic inside the render instead of using an effect
  const prevValue = React.useRef(null);
  React.useEffect(() => {
    const date = rangePosition === 'start' ? value[0] : value[1];
    if (!adapter.isValid(date)) {
      return;
    }
    const prevDate = rangePosition === 'start' ? prevValue.current?.[0] : prevValue.current?.[1];
    prevValue.current = value;

    // The current date did not change, this call comes either from a `rangePosition` change or a change in the other date.
    // In both cases, we don't want to change the visible month(s).
    if (disableAutoMonthSwitching && prevDate && adapter.isEqual(prevDate, date)) {
      return;
    }
    const displayingMonthRange = calendars - currentMonthCalendarPosition;
    const currentMonthNumber = adapter.getMonth(calendarState.currentMonth);
    const requestedMonthNumber = adapter.getMonth(date);
    if (!adapter.isSameYear(calendarState.currentMonth, date) || requestedMonthNumber < currentMonthNumber || requestedMonthNumber > currentMonthNumber + displayingMonthRange) {
      const newMonth = rangePosition === 'start' ? date :
      // If need to focus end, scroll to the state when "end" is displaying in the last calendar
      adapter.addMonths(date, -displayingMonthRange);
      setVisibleDate({
        target: newMonth,
        reason: 'controlled-value-change'
      });
    }
  }, [rangePosition, value]); // eslint-disable-line

  const baseDateValidationProps = {
    disablePast,
    disableFuture,
    maxDate,
    minDate
  };
  const commonViewProps = {
    disableHighlightToday,
    readOnly,
    disabled
  };
  const [rangePreviewDay, setRangePreviewDay] = React.useState(null);
  const CalendarTransitionProps = React.useMemo(() => ({
    onMouseLeave: () => setRangePreviewDay(null)
  }), []);
  const previewingRange = (0, _dateRangeManager.calculateRangePreview)({
    adapter,
    range: valueDayRange,
    newDate: rangePreviewDay,
    rangePosition
  });
  const handleDayMouseEnter = (0, _useEventCallback.default)((event, newRangePreviewDay) => {
    let cleanNewRangePreviewDay;
    if (valueDayRange[0] == null && valueDayRange[1] == null) {
      cleanNewRangePreviewDay = null;
    } else if ((0, _dateUtils.isWithinRange)(adapter, newRangePreviewDay, valueDayRange)) {
      cleanNewRangePreviewDay = null;
    } else {
      cleanNewRangePreviewDay = newRangePreviewDay;
    }
    if (!(0, _internals.areDatesEqual)(adapter, cleanNewRangePreviewDay, rangePreviewDay)) {
      setRangePreviewDay(cleanNewRangePreviewDay);
    }
  });
  const slotsForDayCalendar = (0, _extends2.default)({
    day: _DateRangePickerDay.DateRangePickerDay
  }, slots);
  const slotPropsForDayCalendar = (0, _extends2.default)({}, slotProps, {
    day: dayOwnerState => {
      const {
        day,
        isDaySelected
      } = dayOwnerState;
      const isSelectedStartDate = (0, _dateUtils.isStartOfRange)(adapter, day, valueDayRange);
      const isSelectedEndDate = (0, _dateUtils.isEndOfRange)(adapter, day, valueDayRange);
      const shouldInitDragging = !shouldDisableDragEditing && valueDayRange[0] && valueDayRange[1];
      const isElementDraggable = shouldInitDragging && (isSelectedStartDate || isSelectedEndDate);
      let datePosition;
      if (isSelectedStartDate) {
        datePosition = 'start';
      } else if (isSelectedEndDate) {
        datePosition = 'end';
      }
      const isStartOfHighlighting = isDragging ? (0, _dateUtils.isStartOfRange)(adapter, day, draggingRange) : isSelectedStartDate;
      const isEndOfHighlighting = isDragging ? (0, _dateUtils.isEndOfRange)(adapter, day, draggingRange) : isSelectedEndDate;
      return (0, _extends2.default)({
        isPreviewing: shouldHavePreview ? (0, _dateUtils.isWithinRange)(adapter, day, previewingRange) : false,
        isStartOfPreviewing: shouldHavePreview ? (0, _dateUtils.isStartOfRange)(adapter, day, previewingRange) : false,
        isEndOfPreviewing: shouldHavePreview ? (0, _dateUtils.isEndOfRange)(adapter, day, previewingRange) : false,
        isHighlighting: (0, _dateUtils.isWithinRange)(adapter, day, isDragging ? draggingRange : valueDayRange),
        isStartOfHighlighting,
        isEndOfHighlighting: isDragging ? (0, _dateUtils.isEndOfRange)(adapter, day, draggingRange) : isSelectedEndDate,
        onMouseEnter: shouldHavePreview ? handleDayMouseEnter : undefined,
        // apply selected styling to the dragging start or end day
        isVisuallySelected: isDaySelected || isDragging && (isStartOfHighlighting || isEndOfHighlighting),
        'data-position': datePosition
      }, dragEventHandlers, {
        draggable: isElementDraggable ? true : undefined
      }, (0, _resolveComponentProps.default)(slotProps?.day, dayOwnerState) ?? {});
    }
  });
  const calendarMonths = React.useMemo(() => Array.from({
    length: calendars
  }).map((_, index) => index), [calendars]);
  const visibleMonths = React.useMemo(() => {
    if (process.env.NODE_ENV !== 'production') {
      if (currentMonthCalendarPosition > calendars || currentMonthCalendarPosition < 1) {
        (0, _warning.warnOnce)(['MUI X: The `currentMonthCalendarPosition` prop must be an integer between `1` and the amount of calendars rendered.', 'For example if you have 2 calendars rendered, it should be equal to either 1 or 2.']);
      }
    }
    const firstMonth = adapter.addMonths(calendarState.currentMonth, 1 - currentMonthCalendarPosition);
    return Array.from({
      length: calendars
    }).map((_, index) => adapter.addMonths(firstMonth, index));
  }, [adapter, calendarState.currentMonth, calendars, currentMonthCalendarPosition]);
  const hasFocus = focusedView !== null;
  const prevOpenViewRef = React.useRef(view);
  React.useEffect(() => {
    // If the view change and the focus was on the previous view
    // Then we update the focus.
    if (prevOpenViewRef.current === view) {
      return;
    }
    if (focusedView === prevOpenViewRef.current) {
      setFocusedView(view, true);
    }
    prevOpenViewRef.current = view;
  }, [focusedView, setFocusedView, view]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(DateRangeCalendarRoot, (0, _extends2.default)({
    ref: ref,
    className: (0, _clsx.default)(classes.root, className),
    ownerState: ownerState
  }, other, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_xLicense.Watermark, {
      packageName: "x-date-pickers-pro",
      releaseInfo: releaseInfo
    }), calendarMonths.map(monthIndex => {
      const month = visibleMonths[monthIndex];
      const labelId = `${id}-grid-${monthIndex}-label`;
      return /*#__PURE__*/(0, _jsxRuntime.jsxs)(DateRangeCalendarMonthContainer, {
        className: classes.monthContainer,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(CalendarHeader, (0, _extends2.default)({}, calendarHeaderProps, {
          month: month,
          monthIndex: monthIndex,
          labelId: labelId
        })), /*#__PURE__*/(0, _jsxRuntime.jsx)(DayCalendarForRange, (0, _extends2.default)({
          className: classes.dayCalendar
        }, calendarState, baseDateValidationProps, commonViewProps, {
          onMonthSwitchingAnimationEnd: onMonthSwitchingAnimationEnd,
          onFocusedDayChange: focusedDate => setVisibleDate({
            target: focusedDate,
            reason: 'cell-interaction'
          }),
          reduceAnimations: reduceAnimations,
          selectedDays: value,
          onSelectedDaysChange: handleSelectedDayChange,
          currentMonth: month,
          TransitionProps: CalendarTransitionProps,
          shouldDisableDate: wrappedShouldDisableDate,
          hasFocus: hasFocus,
          onFocusedViewChange: isViewFocused => setFocusedView('day', isViewFocused),
          showDaysOutsideCurrentMonth: calendars === 1 && showDaysOutsideCurrentMonth,
          dayOfWeekFormatter: dayOfWeekFormatter,
          loading: loading,
          renderLoading: renderLoading,
          slots: slotsForDayCalendar,
          slotProps: slotPropsForDayCalendar,
          fixedWeekNumber: fixedWeekNumber,
          displayWeekNumber: displayWeekNumber,
          timezone: timezone,
          gridLabelId: labelId
        }))]
      }, monthIndex);
    })]
  }));
});
if (process.env.NODE_ENV !== "production") DateRangeCalendar.displayName = "DateRangeCalendar";
process.env.NODE_ENV !== "production" ? DateRangeCalendar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: _propTypes.default.bool,
  /**
   * Range positions available for selection.
   * This list is checked against when checking if a next range position can be selected.
   *
   * Used on Date Time Range pickers with current `rangePosition` to force a `finish` selection after just one range position selection.
   * @default ['start', 'end']
   */
  availableRangePositions: _propTypes.default.arrayOf(_propTypes.default.oneOf(['end', 'start']).isRequired),
  /**
   * The number of calendars to render.
   * @default 2
   */
  calendars: _propTypes.default.oneOf([1, 2, 3]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: _propTypes.default.object,
  className: _propTypes.default.string,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: _propTypes.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {PickerValidDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: PickerValidDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: _propTypes.default.func,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: _propTypes.default.oneOf(['end', 'start']),
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: _propTypes.default.arrayOf(_propTypes.default.object),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: _propTypes.default.bool,
  /**
   * If `true`, the component is disabled.
   * When disabled, the value cannot be changed and no interaction is possible.
   * @default false
   */
  disabled: _propTypes.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: _propTypes.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: _propTypes.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: _propTypes.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: _propTypes.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: _propTypes.default.bool,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: _propTypes.default.number,
  /**
   * Controlled focused view.
   */
  focusedView: _propTypes.default.oneOf(['day']),
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: _propTypes.default.bool,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: _propTypes.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: _propTypes.default.object,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TView The view type. Will be one of date or time views.
   * @param {TValue} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
   * @param {TView | undefined} selectedView Indicates the view in which the selection has been made.
   */
  onChange: _propTypes.default.func,
  /**
   * Callback fired on focused view change.
   * @template TView
   * @param {TView} view The new view to focus or not.
   * @param {boolean} hasFocus `true` if the view should be focused.
   */
  onFocusedViewChange: _propTypes.default.func,
  /**
   * Callback fired on month change.
   * @param {PickerValidDate} month The new month.
   */
  onMonthChange: _propTypes.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: _propTypes.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: _propTypes.default.func,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: _propTypes.default.oneOf(['day']),
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: _propTypes.default.oneOf(['end', 'start']),
  /**
   * If `true`, the component is read-only.
   * When read-only, the value cannot be changed but the user can interact with the interface.
   * @default false
   */
  readOnly: _propTypes.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: _propTypes.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`.
   */
  referenceDate: _propTypes.default.object,
  /**
   * Component rendered on the "day" view when `props.loading` is true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: _propTypes.default.func,
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @param {PickerValidDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: _propTypes.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: _propTypes.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: _propTypes.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: _propTypes.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object, _propTypes.default.bool])), _propTypes.default.func, _propTypes.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: _propTypes.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: _propTypes.default.arrayOf(_propTypes.default.object),
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: _propTypes.default.oneOf(['day']),
  /**
   * Available views.
   */
  views: _propTypes.default.arrayOf(_propTypes.default.oneOf(['day']))
} : void 0;