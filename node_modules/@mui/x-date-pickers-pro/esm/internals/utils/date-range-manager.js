import { mergeDateAndTime } from '@mui/x-date-pickers/internals';
export function calculateRangeChange({
  adapter,
  range,
  newDate: selectedDate,
  rangePosition,
  allowRangeFlip = false,
  shouldMergeDateAndTime = false,
  referenceDate
}) {
  const start = !adapter.isValid(range[0]) ? null : range[0];
  const end = !adapter.isValid(range[1]) ? null : range[1];
  if (shouldMergeDateAndTime && selectedDate) {
    // If there is a date already selected, then we want to keep its time
    if (start && rangePosition === 'start') {
      selectedDate = mergeDateAndTime(adapter, selectedDate, start);
    }
    if (end && rangePosition === 'end') {
      selectedDate = mergeDateAndTime(adapter, selectedDate, end);
    }
  }
  const newSelectedDate = referenceDate && selectedDate && shouldMergeDateAndTime ? mergeDateAndTime(adapter, selectedDate, referenceDate) : selectedDate;
  if (rangePosition === 'start') {
    const truthyResult = allowRangeFlip ? {
      nextSelection: 'start',
      newRange: [end, newSelectedDate]
    } : {
      nextSelection: 'end',
      newRange: [newSelectedDate, null]
    };
    return Boolean(end) && adapter.isAfter(newSelectedDate, end) ? truthyResult : {
      nextSelection: 'end',
      newRange: [newSelectedDate, end]
    };
  }
  const truthyResult = allowRangeFlip ? {
    nextSelection: 'end',
    newRange: [newSelectedDate, start]
  } : {
    nextSelection: 'end',
    newRange: [newSelectedDate, null]
  };
  return Boolean(start) && adapter.isBeforeDay(newSelectedDate, start) ? truthyResult : {
    nextSelection: 'start',
    newRange: [start, newSelectedDate]
  };
}
export function calculateRangePreview(options) {
  if (options.newDate == null) {
    return [null, null];
  }
  const [start, end] = options.range;
  const {
    newRange
  } = calculateRangeChange(options);
  if (!start || !end) {
    return newRange;
  }
  const [previewStart, previewEnd] = newRange;
  return options.rangePosition === 'end' ? [end, previewEnd] : [previewStart, start];
}